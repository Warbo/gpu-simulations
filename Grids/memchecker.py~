#!/usr/bin/env python

import sys
from pymeta.grammar import OMeta

def concatenate_dictionaries(original_dictionary, to_add):
	"""Returns the original_dictionary with the contents of the
	dictionaries given in the list too_add inserted."""
	for dic in to_add:
		original_dictionary.update(dic)
	return original_dictionary

dump_grammar = """

grid ::= <token "GRID:"> <address>:grid_address '{' <grid_contents>*:c '}'					=> concatenate_dictionaries({'TYPE':'GRID', 'ADDRESS':grid_address}, c)

grid_contents ::= <x_size> | <y_size> | <z_size> | <population> | <cells> | <particles>

x_size ::= <token "X:"> <integer>:size ','*									=> {'X':size}

y_size ::= <token "Y:"> <integer>:size ','*									=> {'Y':size}

z_size ::= <token "Z:"> <integer>:size ','*									=> {'Z':size}

x_pos ::= <token "X:"> <decimal>:pos ','*									=> {'X':pos}

y_pos ::= <token "Y:"> <decimal>:pos ','*									=> {'Y':pos}

z_pos ::= <token "Z:"> <decimal>:pos ','*									=> {'Z':pos}

population ::= <token "POPULATION:"> <integer>:pop ','*								=> {'POPULATION':pop}

cells ::= <token "CELLS:STARTINGAT:"> <address>:startaddress '{' <cells_contents>*:c '}' ','*			=> {'CELLS':c, 'CELLSSTART':startaddress}

cells_contents ::= <cell>:c											=> c

cell ::= <token "CELL:"> <address>:celladdress '{' <cell_contents>*:c '}' ','*					=> concatenate_dictionaries({'TYPE':'CELL', 'ADDRESS':celladdress}, c)

cell_contents ::= <neighbours>:n										=> n
                | <first_particle>:p										=> p

neighbours ::= <token "NEIGHBOURS:STARTINGAT:"> <address>:startaddress '{' <neighbour>*:n '}' ','*		=> {'NEIGHBOURS':n, 'NEIGHBOURSSTART':startaddress}

neighbour ::= <token "LOCATION:"> <address>:location ','*							=> location

first_particle ::= <token "FIRSTPARTICLE:"> <address>:particleaddress ','*					=> {"FIRSTPARTICLE":particleaddress}

particles ::= <token "PARTICLES:STARTINGAT:"> <address>:startaddress '{' <particles_contents>*:c '}' ','*	=> {'PARTICLES':c, 'PARTICLESSTART':startaddress}

particles_contents ::= <particle>:p										=> p

particle ::= <token "PARTICLE:"> <address>:particleaddress '{' <particle_contents>*:c '}' ','*			=> concatenate_dictionaries({'TYPE':'PARTICLE', 'ADDRESS':particleaddress}, c)

particle_contents ::= <x_pos> | <y_pos> | <z_pos> | <container> | <next>

container ::= <token "CONTAINER:"> <address>:containeraddress ','*						=> {'CONTAINER':containeraddress}

next ::= <token "NEXT:"> <address>:nextparticle ','*								=> {'NEXT':nextparticle}

address ::= <integer>:memaddress										=> memaddress
         | <token "NULL">											=> None

integer ::= '-' <dig>+:ds											=> -1*int(''.join(ds))
          | <dig>+:ds												=> int(''.join(ds))
      
dig ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
          
decimal ::= <integer>:whole '.' <dig>+:frac									=> float(str(whole)+'.'+''.join(frac))
          | <integer>
"""

# Make a class which reads the dump grammar
grammar = OMeta.makeGrammar(dump_grammar, globals())

# Exit if we've been given no file to check
if len(sys.argv) < 2:
	print "Usage: memchecker.py DUMP_FILE"
	sys.exit()
	
# Open the given file
infile = open(sys.argv[1], 'r')

inlines = ''.join(infile.readlines())

infile.close()

# Instantiate the dump grammar with the input
matcher = grammar(inlines)

# Try to find a dump in the input
grid = matcher.apply('grid')

# Now we should have a dictionary of the program internals, so run some tests

# If there are cells, do checks on them
if 'CELLS' in grid.keys():
	
	# Make sure that CELLS doesn't appear without CELLSTART
	if 'CELLSSTART' not in grid.keys():
		print "Grid has cells, but no cells start address!"
		sys.exit()
	
	# If we've more than one cell then the spacing between all cells should be equal
	if len(grid['CELLS']) > 1:
		cell_spacing =  grid['CELLS'][1]['ADDRESS'] - grid['CELLS'][0]['ADDRESS']
		
		# Make sure the first two cells follow on from each other in memory
		if cell_spacing < 1:
			print "Second cell ("+str(grid['CELLS'][1]['ADDRESS'])+") doesn't continue from first ("+str(grid['CELLS'][0]['ADDRESS'])+")!"
			print "ALL CELLS:"+str([' '+str(c['ADDRESS'])+' ' for c in grid['CELLS']])
			sys.exit()
	
	# If we've not got more than one cell then set the spacing to None so that we know not to check it
	else:
		cell_spacing = None
	
	# Do checks for each cell
	for cell in grid['CELLS']:
		
		# Make sure that the cell is not stored before the cells' start address
		if cell['ADDRESS'] < grid['CELLSSTART']:
			print "Cells start at "+grid['CELLSSTART']+' but found a cell starting at '+cell['ADDRESS']+'!'
			sys.exit()
		
		# If we've more than one cell then make sure that the cell is an integer number of spaces from the cell start address
		if cell_spacing is not None and (cell['ADDRESS'] - grid['CELLSSTART']) % cell_spacing > 0:
			print "Cell "+str(cell['ADDRESS'])+" is not an integer number of cells away from start address "+str(grid['CELLSSTART'])+" (assuming cell spacing of "+str(cell_spacing)+")"
			sys.exit()
		
		# Do checks on this cell's first particle, if it has one
		if ('FIRSTPARTICLE' in cell.keys()) and (cell['FIRSTPARTICLE'] is not None) and ('PARTICLESSTART' in grid.keys()):
			
			# Make sure that the first particle does not come before the particles' start address
			if cell['FIRSTPARTICLE'] < grid['PARTICLESSTART']:
				print "Cell contains particle "+cell['FIRSTPARTICLE']+' but particles start at '+grid['PARTICLESSTART']
			
			# Make sure that the first particle is in the list of particles
			if cell['FIRSTPARTICLE'] not in [p['ADDRESS'] for p in grid['PARTICLES']]:
				print "Cell contains particle "+cell['FIRSTPARTICLE']+" but not in particles list "+str([p['ADDRESS'] for p in grid['PARTICLES']])
				sys.exit()
		
		# If we've no particles then do some further checks
		else:
			# If there are particles in the grid then make sure none of them gives this cell as its container (since the cell thinks it's empty)
			if 'PARTICLES' in grid.keys():
				for particle in grid['PARTICLES']:
					if particle['CONTAINER'] == cell['ADDRESS']:
						print "Cell "+str(cell['ADDRESS'])+" says it has no particles, but particle "+str(particle['ADDRESS'])+" says it is in this cell!"
						sys.exit()
		
		# If we've enabled cell neighbour allocation then look for problems in the neighbour assignments			
		if 'NEIGHBOURS' in cell.keys():
			
			# Make sure we've got 26 neighbours + ourself
			if len(cell['NEIGHBOURS']) != 27:
				print "Neighbour length is not 27 for cell "+str(cell['ADDRESS'])+"!"
			
			# Find the position of this cell
			# Our indexing scheme for the cells should be (y*z)*x_index+(z)*y_index+z_index, so let's invert that
			z = ((cell['ADDRESS'] - grid['CELLSSTART']) % (grid['Y']*grid['Z'])) % grid['Z']
			y = (((cell['ADDRESS'] - grid['CELLSSTART']) - z) % (grid['Y']*grid['Z'])) / grid['Z']
			x = (((cell['ADDRESS'] - grid['CELLSSTART']) - z) - (grid['Z']*y)) / (grid['Y']*grid['Z'])
			
			print str([x, y, z]) + ' has ' + str(len([n for n in cell['NEIGHBOURS'] if n is not None])) + ' neighbours' 

# If there are no cells then make sure there really aren't any
else:
	
	# Make sure that CELLSSTART doesn't appear without CELLS
	if 'CELLSSTART' in grid.keys():
		print "Grid has cell start address, but no cells!"
		sys.exit()
				
